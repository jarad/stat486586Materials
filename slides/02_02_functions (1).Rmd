---
title: "Functions"
subtitle: "STAT486/586"
author: "Xiongtao Dai"
output:
  xaringan::moon_reader:
    mathjax: "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML"
    css: [myslides.css, myslides-fonts.css]
    lib_dir: libs
    nature:
      beforeInit: "macros.js"
      highlightLines: true
      countIncrementalSlides: false
---
class: big, middle

```{r xaringan-tile-view, echo=FALSE}
xaringanExtra::use_tile_view()
```

## Functions

---

## Outline

- Defining functions

- Environment

- Unit tests

- Documenting functions

---

## Functions in R

- Often times we need to perform a task repeatedly. E.g., run a linear regression on different datasets

- Like data structures which put related data together, functions put related code together

- Instead of copying and pasting code, you would write a function which contains the common core code

- Functions are *reusable*, so this avoid repetitive coding (errors will creep in)

- Functions are *more maintainable*. As the requirements evolve, you only need to modify code in one place if you write a function, instead of looking into many places

---

## Repetivie code

Suppose we want to standardize a few vectors. Without a function, you would do some copying and pasting: 
```{r, echo=FALSE}
x <- 1:5
y <- c(1:5, 10)
z <- c(-1, 1, 3)
w <- c(1, 3, NA, 5)

(x - mean(x)) / sd(x) 
(y - mean(y)) / sd(y) 
(z - mean(y)) / sd(z)
(w - mean(w)) / sd(w) 
```

In fact, there is an error. Did you spot it?

---

## A first function
So we are going to write a function to avoid repetitive code

```{r}
standardize <- function(x) {
	return((x - mean(x)) / sd(x))
}
```

```{r}
standardize(x)
```

---

## Structure of functions

- Function name
    - Should be intuitive. Usually a verb

- Input arguments, some with default values
    - names: again, should be intuitive
    
- Body

- Output values
    - the `return()` statement is optional

---

## A first function (2)

To add an optional argument `na.rm` with default value `FALSE` for removing missing values when calculating the mean and standard deviation:

```{r}
standardize <- function(x, na.rm=FALSE) {
	(x - mean(x, na.rm=na.rm)) / sd(x, na.rm=na.rm)
}

standardize(x)
standardize(w)
standardize(w, na.rm=TRUE)
```

---

## A first function (3)

Return a list in order to return multiple objects:

```{r}
standardize <- function(x, na.rm=FALSE) {
  m <- mean(x, na.rm=na.rm)
  s <- sd(x, na.rm=na.rm)
	list(standardized = (x - m) / s,
	     mean = m,
	     sd = s)
}

standardize(x)
```

---

## R demo...

---
class: inverse

## Your turn

<img src="images/blue.png" width=20> Implement a function `mymean` with a single vector input `x` that outputs the mean of `x`, without using the `mean` function

<img src="images/green.png" width=20> Call your function on `c(1, 3, 4)` and `c(1, 3, 4, 5)`. Make sure your function has the same output as `mean()`

<img src="images/blue.png" width=20> Now, add a second optional argument to `mymean`, which is a flag `na.rm` that defaults to `FALSE` to indicate whether to remove missing values before the mean calculation. You may use `is.na()`. Again, compare the results from your function and `mean()` to make sure your implementation is correct


---

## Your turn solutions

```{r}
mymean <- function(x, na.rm=FALSE) {
  if (na.rm) {
    x <- x[!is.na(x)]
  }
  
  sum(x) / length(x)
}
```

---

## How to write a function

<!-- - When writing a more complex function, the key considerations are -->
<!--   - The purpose of the function -->
<!--   - The inputs of the functions -->
<!--   - The outputs -->
<!--   - How to write the body -->

A typical procedure for writing a function:

1. Think about what the function should and should not do
    - One function should do one task nicely. A large task could be separated into multiple functions
    
1. Decide what information are needed as inputs. Think about the arguments to write

1. Determine the output (one object, or more?)

1. Write the body
    - Again, break a large task into smaller parts
    - Figure out how to fit the parts together

---

## A more extended example

The function should calculate different location estimates for a vector. 
It should support the mean, median, and trimmed mean

TODO

---

## Testing your function

- Making sure your code and results are correct is the #1 priority (then readablity, stability, speed, etc)

- *Unit testing* is a procedure of testing a small unit of code in a software. A unit is often a function

- Writing a unit test is not difficult at all. After you finish a freshly written function, you must have written some code to see whether it works or not. *Do not discard the code*, but rather make it a formal unit test

---

## The `testthat` package

- `testthat` is a package for unit testing your code

- `testthat` tries to make testing as fun as possible

- Issue `install.packages("testthat")` in your R console if you haven't installed it

- Load the package 
    ```{r}
    library(testthat)
    ```

- The main workhorses is the expectation/assertion function

    ```
    expect_equal(object, expected, ..., tolerance)
    ```

---

## `expect_equal`

```
expect_equal(object, expected, ..., tolerance)
```

- `expect_equal` tests whether the output of your code matches your expectation

- If matched, nothing happens, meaning that the test is happily passed

- If not, you have an error, so you must go back and check your code or the test


---

A very basic example:
```{r}
expect_equal(mean(1:3), 2)
```

By default, differences below a small threhold will be regarded OK. This is very useful when comparing floating point numbers or numerical algorithms
```{r, error=TRUE}
expect_equal(mean(1:3), 2 + 1e-8)
```

`tolerance=` sets the threshold
```{r, error=TRUE}
expect_equal(mean(1:3), 2 + 1e-8, tolerance = 1e-10)
```

---
## Writing good tests

A unit test tests whether a specific aspect of your code meets your expectation. For example,

- the output has the same length or dimensions as the input

- the output equals what you expect in a simple case

- the output behaves correctly in corner cases, such as when $n=1$

- an optional argument is functional

---
## Examples

- Make sure the output has the right length:
```{r}
x <- c(NA, 1:3)
expect_equal(length(standardize(x)$standardized), length(x))
```

- Benchmark your function against an existing function to make sure yours is correct:
```{r}
y <- c(1, 3, 5, 10)
expect_equal(mymean(y), mean(y))
```

- Test the corner case with missing values
```{r}
z <- c(1, NA)
expect_equal(is.na(mymean(z)), TRUE)
expect_equal(is.na(mymean(z, na.rm=TRUE)), FALSE)
```

---

## Documenting functions

- Documentation is one of the fundamental part of a piece of software

- It helps the users of your code, which include your future self!

- Writing documentation also help you better think about the function. If you can neatly and concisely describe it, your function is probably logically sound

- The documentation of a function has the following most important parts

    1. A quick overview of the purpose of the function
    1. Description of the inputs. This should include argument names and the expected formats of the inputs.
    1. Description of the outputs. What do you return?
    1. Optionally, include some details of the implementation/algorithm and list some example usages
    
- R documentations are good examples. See, e.g., `?diff`

---

## An example
The documentation of the `mymean` function is included as comments (lines starting with `#`) before the definition of the function.
```
# Calculate the mean of a vector, without using the mean() function
# x: A numerical vector 
# na.rm: A flag to indicate whether missing values should be removed 
#        before the mean calculation
# 
# Returns the scalar mean of the vector
mymean <- function(x, na.rm=FALSE) {
  if (na.rm) {
    x <- x[!is.na(x)]
  }
  
  sum(x) / length(x)
}
```