---
title: "Control Flow"
subtitle: "STAT486/586"
author: "Xiongtao Dai"
output:
  xaringan::moon_reader:
    mathjax: "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML"
    css: [myslides.css, myslides-fonts.css]
    lib_dir: libs
    nature:
      beforeInit: "macros.js"
      highlightLines: true
      countIncrementalSlides: false
---
class: big, middle

```{r xaringan-tile-view, echo=FALSE}
xaringanExtra::use_tile_view()
```

## Control Flow

---

## Outline

- Grouping expressions

- Conditional: `if, else`

- Short circuiting logical operations `&&` and `||`

- Iterations/loops: `for` and `while`

- Loop control statements: `break`, and `next`

---

## Grouping expressions

- Each line in R is an expression

- When using conditionals and loops, we would like a block of expressions to be grouped together and evaluated like a single one

- R uses curly braces to block expressions. E.g.,

    ```
    {
      writeLines("Flash says: What"s the plate")
      Sys.sleep(2)
      writeLines("number?")
    }
    ```

---

`system.time(expr)` times how long does it take to run a single expression

- This works:
    ```
    system.time(writeLines("What"s the plate number?"))
    ```
- This does not work

    ```
    system.time(
      writeLines("Flash says: What"s the plate")
      Sys.sleep(2)
      writeLines("number?"))
    ```
- Grouping the expression works:
    ```
    system.time({
      writeLines("Flash says: What"s the plate")
      Sys.sleep(2)
      writeLines("number?")
    })
    ```
    
    - user: time used by computation
    - system: time used by input/output, etc
    - elapsed: wall time
---

## Expression values

- The value of the grouped expression is the last expression in the group

```{r}
x <- {
  1
  # do something else
  2
}
x
```

---
## The `if` and `else` statements

- The `if` and `else` statements offers a way to evaluate a block of code depending on a condition

    ```
    # Not real code
    if (condition) {
      code to be run only if the condition is true
    } 
    code to be run no matter what
    ```
    
    ```
    if (condition) {
      code to be run if the condition is true
    } else {
      code to be run otherwise
    }
    ```

- `condition` need to evaluate to a single logical value

---

E.g. 
```{r, collapse=TRUE}
wantAJoke <- TRUE # try setting to FALSE
if (wantAJoke) {
  writeLines("What do you call a three humped camel? Pregnant")
}
writeLines("Go back to work!")
```

```{r, collapse=TRUE}
wantAJoke <- TRUE # try setting to FALSE
if (wantAJoke) {
  writeLines("What do you call a three humped camel? Pregnant")
} else {
  writeLines("Go back to work!")
}
```

---

You can chain `if` and `else` together to evaluate blocks depending a series of conditions

```{r}
today <- "Tuesday"
if (today == "Monday") {
  writeLines("Tell me a joke")
} else if (today == "Tuesday") {
  writeLines("Work work")
} else if (today == "Friday") {
  writeLines("Ready to break")
} else {
  writeLines("Have some fun")
}
```

---

## Short-circuiting logical operations

- Recall that previously we learned the vectorized operations `&` and `|`

- We now look at `&&` and `||`, which are *short-circuiting logical operations*

- `&&` and `||` operates on a pair of conditions (not vectors)

- For `&&`, if the first condition evaluates to `FALSE` (enough to determine the outcome), then the second condition will not be evaluated

- Similarly, for `||`, if the first condition evaluates to `TRUE`, then the second condition will not be evaluated

- .style[When programming conditions, use `&&` and `||` but not the vectorized versions]

---

E.g.

Compare `&&`

```{r}
x <- 1
if (length(x) > 1 && length(optionalInput) > 1) { #<<
  writeLines("Run vector algorithm")
} else {
  writeLines("Run scalar algorithm")
}
```

with `&`
```{r, error=TRUE}
x <- 1
if (length(x) > 1 & length(optionalInput) > 1) { #<<
  writeLines("Run vector algorithm")
} else {
  writeLines("Run scalar algorithm")
}
```

---

E.g.

Compare `||`

```{r}
x <- 1:3
if (length(x) > 1 || length(optionalInput) > 1) { #<<
  writeLines("Run vector algorithm")
} else {
  writeLines("Run scalar algorithm")
}
```

with `|`
```{r, error=TRUE}
x <- 1:3
if (length(x) > 1 | length(optionalInput) > 1) { #<<
  writeLines("Run vector algorithm")
} else {
  writeLines("Run scalar algorithm")
}
```

---

## `ifelse`

- Recall the `ifelse` *function*, which is not a control flow statement.

- `ifelse(test, yes, no)` is vectorized. All three arguments can be a vector (but the `condition` for an `if` statement needs to be a scalar)

.pull-left[
Each entry in the result of `ifelse` depends on each entry of `test` (a vector)
```{r}
x <- -1:1
ifelse(x >= 0, "pos", "neg")
```
]

.pull-right[
The entire result of `if` depends on `condition` (a scalar)
```{r}
x <- -1
if (x >= 0) {
  "pos"
} else {
  "neg"
}
```
]

---

## Iterations/loops

- Many programs/algorithms/tasks rely on iterations

- Computer programs are excellent in performing repeated tasks, but humans are much less so

- R offers some standard control flow statements for iterations/loops:

    ```
    for (i in valuesToLoopOver) {...}
    while (conditionIsTrue) {...}
    
    break
    next
    ```
---

## The `for` loop

```
for (i in valuesToBeLoopedOver) {
  Do something depending on i
}
```

- The braces `{}` contains the body of the loop

- The `i` is a "counter". The body of the loop can use `i` as a variable

- The values in `valuesToBeLoopedOver` will be used one by one sequentially

- `for` loop is great for repeating a statement for a prespecified number of times

- All loops can be nested and mixed with `if` and `else`

---
The loop body can depend on `i`
```{r, collapse=TRUE}
sum <- 0
for (i in 1:3) {
  sum <- sum + i
  writeLines(stringr::str_c("i: ", i, " sum: ", sum))
}
```

You can loop over strings
```{r, collapse=TRUE}
for (method in c("mean", "trimmed.mean")) {
  writeLines(stringr::str_c("Using method: ", method))
}
```

or even functions
```{r, collapse=TRUE}
for (func in list(mean, var)) {
  print(func(1:5))
}
```

---

Initialize a vector to store the value from the for loop is often a good idea for speed and memory.

E.g., calculate the cumulative sum of 1 to 10
```{r, collapse=TRUE}
n <- 10
sum <- vector("numeric", length=n)
for (i in 1:n) {
  if (i == 1) {
    sum[i] <- i
  } else {
    sum[i] <- sum[i - 1] + i
  }
}
sum
```

---

## The `while` loop

```
while (conditionIsTrue) {
  do things
  update condition
}
```

A `while` loop repeatedly runs the loop body until the condition is no longer true

```{r}
i <- 1
month <- month.name[i]

while (month != "June") {
  i <- i + 1
  month <- month.name[i]
} 
i
```

---

A `while` loop is used if you do not know when to stop in advance. For example, iterative algorithm where you stop if an error is smaller than the prespecified threshold

E.g.: We use a finite truncated series 
$$\sum_{i=1}^n \frac{(-1)^{i+1}}{i}$$
to approximate
$$\sum_{i=1}^\infty \frac{(-1)^{i+1}}{i}.$$
How do we know the approximation is good?

---

```{r}
tolerance <- 1e-5

# Initialize
n <- 10
total <- 0
error <- Inf

while (error > tolerance) {
  n <- n * 2
  x <- 1:n
  newTotal <- sum((-1)^(x + 1) / x)
  error <- abs(newTotal - total)
  total <- newTotal
}
n
total
```

---

## `break`

- We can stop the iterations early using the `break` statement

```{r}
for (i in 1:1e4) {
  x <- i^2
  writeLines(stringr::str_c(i, "^2 = ", x))
  if (x > 99999) {
    break
  }
}
```

---
`break` be used within `while` as well
```{r, collapse=TRUE}
i <- 1
while (TRUE) {
  month <- month.name[i]
  if (month == "June") {
    break
  } 
  i <- i + 1
}
month
```

`while (TRUE)` is the same as the *`repeat` statement*. This must be used with a `break`, or you will have an infinite loop (in which case, you must press `Ctrl-C` in the R console to interrupt R)
```{r, eval=FALSE}
i <- 1
repeat {
  month <- month.name[i]
  if (month == "June") {
    break
  }
  i <- i + 1
}
month
```
---

## `next`

- `next` is used to exit the current loop early and move on to the next loop

- Great for performing some tasks only if that needs to be done

```{r}
plans <- rep("", 12)
names(plans) <- month.abb
plans[c("Jun", "Jul", "Aug")] <- "have fun"
for (i in seq_along(plans)) {
  if (plans[i] != "") { # Have a plan already
    next
  }
  plans[i] <- "study"
}
plans
```

---
## Wrapping it up

- The `for`, `while`, and `repeat` loops are mostly interchangable. There are always more than one way to perform the task (with the control statements)

- Which loop to use depends on which is the most intuitive to understand

---

## R demo...

